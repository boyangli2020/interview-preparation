CAP原理（分布式系统要实现的目标）：
	Consistency：强一致性，就是说所有的服务器上面的数据都是一样的，（只有一个服务器）
	Availablity：可用性，用户访问服务器上面的数据，响应时间在可以接受的范围内（不需要等待）
	Partition tolerance：分区容忍性，其实就是高可用性，一个节点崩了，并不影响我们其它的节点（多台服务器）

	一个分布式系统CAP只能同时满足两个。一般来讲，分区容错性是必须满足的，也就是一个分布式系统的基本要求时满足高可用。
		CA: 如果放弃P，也就是单节点，那么C和A都是可以保障的。
		CP: 在分布式P的基础上，如果要保证数据一致性，不同节点同步数据需要时间，如果网络不稳定就会影响用户体验，所以不能满足可用性。
		AP: 在分布式P的基础上，如果要保证可用性，每个节点为了保证相应时间，只能用本地当前数据提供服务，但数据可能没有完全在每个节点上进行同步。

BASE理论：
	Basically Available: 基本可用
	Soft state: 软状态，可以有中间状态，如支付中，这样查询时候返回支付中系统还是可用的。
	Eventually consistent: 最终一致性，支付完成后将订单变成成功。
	
	BASE是对CAP中一致性和可用性权衡的结果。源于大规模互联网系统分布式实践的结论。核心是:
		即使无法做到强一致性（Strong Consistency）, 但每个应用可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

REDIS 默认有16个数据库，角标从0到15，select 5(切换到第6号库)，这样可以通过业务去区分数据库。
	dbsize：查询当前数据库key的数量
	keys *: 查看所有key, 一般别用
	keys my?: 使用通配符查看my大头的所有key
	flushdb: 清空当前库
	flushall: 清空所有的16个库
	

数据类型：
	String字符串：
		String是二进制安全的，意思是可以包含任何数据，比如jpg图片或者序列化的对象。
		一个String类型的value最多是512MB.
		
	Hash哈希：
		string类型的field和value的映射表，hash特别适合存储对象。类似与Java中的Map<String,Object>
	
	List列表：
		简单的字符串列表，按照插入顺序排序，可以添加一个元素到表的头部（左边）或者尾部（尾部）。底层是一个链表。
	
	Set：
		string类型的无序集合，是通过hashtable实现的。
	
	ZSet:
		string类型的集合, 和Set的区别是每个元素都关联了一个double类型的分数。通过分数来对集合中元素进行从小到达的排序。ZSet的成员是唯一的，但是分数score可以重复。

REDIS 1(key)+5(5种数据类型)
		
	
命令：	
	keys *: 列出所有key
	exits keyname:判断某个key是否存在 exits k1
	move key dbname: 将key和对应value从当前库移动到指定的数据库种  move k1 1
	exipre key 时间(秒): 为给定的key设置过期时间 -1永不过期  -2已过期   expire k1 10
	ttl key: 查看还有多少秒过期，ttl time to leave.  ttl k1
	del key: 删除操作
	type key: 查看key的数据类型
	set key value: 设置值
	setex key 时间(秒) 值：set with expire  setex k4 10 v4
	setnx: set if not exit, setnx k1 5, 为了防止覆盖，返回1表示设置成功，0标识设置失败


当Redis中内存不足的时候，为了保证命中率，就会选择一定的数据淘汰策略。
	volatile（从已经设置过期时间的key中）
	allkeys（所有的key中）
		1）volatile-lru（key通过最后访问时间升序排序，删除最小的）：当内存不足时，从设置了过期时间的key中使用LRU（最近最少使用）算法，选出最近使用最少的数据，进行淘汰；
		2）allkeys-lru：当内存不足时，从所有key中使用LRU（最近最少使用）算法，选出最近使用最少的数据，进行淘汰。
		3）volatile-lfu（key通过被访问次数进行计数升序排序，删除最小的）：当内存不足时，从设置了过期时间的key中使用LFU算法，选出使频率最低的数据，进行淘汰。
		4）allkeys-lfu：当内存不足时，从所有key中使用LFU算法，从所有key中使用LFU算法，选出使频率最低的数据，进行淘汰。
		5）volatile-random：当内存不足时，从设置了过期时间的key中，随机选出数据，进行淘汰。
		6）allkeys-random：当内存不足时，从所有的key中，随机选出数据，进行淘汰。
		7）volatile-ttl：当内存不足时，从设置了过期时间的key中，选出即将过期的数据（按照过期时间的先后，选出先过期的数据），进行淘汰。
		8）no-enviction：当内存不足时，禁止淘汰数据，写入操作报错默认策略，是Redis默认的内存淘汰策略


Redis 持久化
	RDB文件，每隔一段时间，复制整个进程，在另一个子进程里面将文件dump进rdb文件，dump.rdb，宕机容易丢失数据
	AOF: 每次写操作先写入aof, 在更新内存，数据不怎么丢失，但是效率不高。每隔一段时间，将aof文件重写，减少文件大小。

Redis主从复制：
	一个master， 多个从节点，从节点可以是另外从节点的master. 
	可以引入哨兵节点，实时ping master, 如果挂了选举更换从节点为master.


Redis分布式锁：
	https://blog.csdn.net/LYQ20010417/article/details/123468307
	
	1. 使用nx(template.setIfAbsent("lock", 111))方法原子性上锁，如果成功执行业务，最后释放锁del(template.delete("lock"))，如果失败，进行重试。
	2. 如果设置锁后宕机会发生锁无法释放，因此设置锁时候设置超时时间，template.setIfAbsent(“lock” , “111”，30，TimeUnit.SECONDS)，这个操作是原子性的。
	3. 如果锁时间已经过期，另一个进程获取到了锁，本进程会删除掉另一个进程的锁，因此，删除锁之前需要redisTemplate.opsForvalue( ).get(“lock” )判断获取的值是否是111，再去删除delete,
		这里get时候可能还没过期，但是Delete时候已经过期了，还是会删除另一个进程的锁，所以getAndDelete需要是原子性操作，因此需要使用脚本执行
		stringRedisTemplate.execute(new DefaultRedisScript<>..
	
	
ZK分布式锁：
	1.客户端获取锁时，在lock节点下创建临时顺序节点
	2.然后获取lock下面所有的子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除
	3.如果发现自己创建的节点并非lock节点下所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件
	4.如果发现比自己小的那个节点被删除，则客户端的Watcher会受到相应通知，此时再判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听

、

Redis雪崩：redis缓存key同一时间大量key失效，导致大量请求全部打到数据库，造成数据库挂掉。
	1. 随机设置redis的失效时间
	2. 定时任务定期延长缓存的失效时间
Redis穿透：请求id = -1 的数据，请求数据库中没有的数据，常见于黑色攻击
	1. 请求的数据就算数据库是空的，也会存在缓存中去，这样下次用同样的数据请求就不会穿透redis
	2. ip拉黑
	3. 参数校验
	4. 布隆过滤器
Redis缓存击穿：某一个非常热点的key, 比如是秒杀商品，当缓存失效，直接打到数据库上。
	1. 缓存永远不过期
	2. 分布式锁，当查到redis热点key没有结果先去获取分布式锁，再去mysql中去查数据同步给redis. 
		其他没有抢到锁的线程先睡几毫秒，再去redis中查询数据，获取到数据返回即可。

Redis与数据库一致性
	1. 先更数据库再更缓存
		请求1更数据库，请求二更数据库，请求二更缓存，请求1更缓存，造成数据不一致。
	2. 先更缓存再更数据库
		请求1更缓存，请求二更缓存，请求二更数据库，请求1更数据库，造成数据不一致。
	3. 先删缓存再更数据库
		请求1删缓存，请求二读缓存未命中，请求二度数据库并更新到缓存，请求一更新数据库，造成数据不一致。
	4. 先更数据库，再删除缓存
		请求1读缓存，未命中，去查询数据库，请求二更新数据库，删除缓存，请求1将读取到的旧值放到缓存中，
		造成数据不一致（一般请求1读数据库后写缓存时很快的，可以让请求二更新完数据库睡几毫秒再去删除缓存来解决）

	
		















	
