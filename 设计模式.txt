UML类图  4种关系
	1.关联关系（类中成员）
		一般关联关系
			单项关联Customer Address
			双向关联Customer Product
			自关联	Node
		聚合关系
			University Teacher
		组合关系
			Head	Mouth
			
	2.依赖关系（方法参数，局部变量，静态方法调用）
			Driver.drive(Car car) 耦合度最低
	
	3.继承关系/泛化关系（耦合度最高）
				Person  
		Student			Teacher
	
	4.实现关系(实现接口) 
				Vehicle
		Car					Ship

软件设计原则  单开李第一结合 7种
	1.单一职责原则
	2.开闭原则				对扩展开放，对修改关闭。在程序需要扩展的时候，不能去修改原有代码，实现一个热插拔的效果。使用接口或抽象类实现。
	3.里氏替换原则			任何基类可以出现的地方，子类一定可以出现。子类可以扩展父类的功能，但不能改变父类原有的功能。
	4.依赖倒转原则			高层模块不应该依赖底层模块，两者都应该以来其抽象，抽象不应该依赖细节，细节应该依赖抽象。面向接口编程。降低客户与实现的耦合度。
	5.接口隔离原则			客户端不应该被迫依赖于他不使用的方法，一个类对另一个类的依赖应该建立在最小的接口上。
	6.迪米特法则			又称为最小知识原则。之和直接朋友交谈，不跟陌生人说话。降低类之间的耦合度。
	7.合成复用原则			尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
	

一、创建型模式：对象创建与使用分离，降低系统耦合，使用者不需要关注对象的创建细节。5种 单按原型建两工厂
	
		1.单例设计模式	
			饿汉式  类加载就实例化对象，如果只是想加载这个类，不适用其对象就会造成空间浪费。
				（a.静态变量方式  b.静态代码块方式）
			懒汉式	存在线程安全问题
				（a.getInstance方法上加synchronized性能低, b.getInstance方法内部双重检查存在指令重排问题，c 双重检查加volatile关键字解决指令重拍 d.内部类方式解决指令重排，e.使用枚举方式）

					public class Singleton implements Serializable {
	
						private static boolean FLAG = false;
	
						private Singleton() {
							sychronized(Singleton.class) {
								if(FLAG) {
									throw new RuntimeException("不能创建多个对象");
								}
							}
							flag = true;
						}
	
						private static class SingletonHolder {
							private static final Singleton INSTANCE = new Singleton();
						}
	
						public static Singleton getInstance() {
							return SingletonHolder.INSTANCE;
						}
						 
						public Object readResolve(){
							return SingletonHolder.INSTANCE;
						}
						
					}
					
			破坏单例模式：
				a. 序列化反序列化（通过复写readResolve方法解决） 
				b. 反射调用构造方法
		
		2.工厂设计模式
			a.简单工厂模式 （具体工厂，抽象产品，具体产品）
				优点：封装了创建对象的过程，可以通过参数直接创建对象。把对象的创建和业务逻辑层分开。新增类型可以在工厂类中添加，而不是在业务逻辑曾添加，降低了客户代码修改的可能性。更加容易扩展。
				缺点：新增产品需要修改工厂类，违背了开闭原则。
			b.静态工厂模式 （具体工厂，抽象产品，具体产品）
				优点：创建对象方法为静态的，好处是客户端不需要new一个工厂对象。
			b.工厂方法模式 （抽象工厂，具体工厂，抽象产品，具体产品）
				优点：添加产品类也要相应地增加工厂类，不需要修改原来工厂类的代码，满足开闭原则。
				缺点：添加产品类也要相应地增加工厂类，增加了系统的复杂度。
			d.抽象工厂模式 （抽象工厂，具体工厂，抽象产品，具体产品）抽象工厂定义了一个产品族的所有创建接口。
				有点：当一个产品族中的多个对象被设计成一起工作时，他保证客户端使用使用一个产品族对象去使用。
				缺点：抽象每新增一个产品时，每个具体工厂都要进行新增。
						
			JDK Collection.iterator使用了工厂方法模式。 Collection是抽象工厂，定义了iterator函数。
			ArrayList是具体工厂，其中iterator函数创建一个类型为ArrayList$Iter的具体产品，ArrayList$Iter是Iterator抽象产品的实现。
			
		3.原型设计模式  用一个已经创建的实例作为原型，通过复制该原型对象来创建一个与原型对象相同的新对象。
			
			抽象原型类，提供clone方法
			具体原型类，实现抽象原型类的clone()方法
			访问类：使用具体原型类的clone()方法复制新的对象。
			
			jdk类继承Object类的clone方法，只要实现Cloneable接口，就可以调用clone方法进行浅克隆。
			
			使用场景：当对象创建非常复杂，可以通过这种快捷的方式创建对象。
			
		4.建造者模式 分离了对象的构造和装配，适用于某个对象的构建过程比较复杂的情况。
			抽象建造者  为创建一个产品的各个组件指定各个接口
			具体建造者
			产品
			指挥者Director  调用具体创建者来创建复杂对象的各个部分，保证产品各个部分完整或者按某个顺序创建。
			
			实际开发中可以指挥者和抽象建造者进行结合，即抽象建造者除了提供装配各个组件的接口外，还提供一个指定创建流程的模板方法。
			
			JobCoreConfiguration.Builder
			如果我这个内部类的创建或者使用不需要依托必须创建外部类对象，其实我就可以把他声明成一个静态的内部类
			
二、结构型模式：类和对象按照某种布局组成更大的结构，分为类结构型模式和对象结构型模式。	7种：装适外观代享组桥
			1.代理模式   静态代理（编译期生成）   动态代理（java运行时动态生成），一般分为JDK和CGLIB两种。
			2.适配器模式	SD卡 TF卡	类适配器模式/对象适配器模式
			3.装饰器模式	咖啡加奶加巧克力粉
			4.桥接模式	Shape,Color	https://www.runoob.com/w3cnote/bridge-pattern2.html  
				抽象化角色Shape，扩展抽象化角色Retangle，实现化角色Color，具体实现化角色Red
				提高的系统的扩展性，两个变化维度中任意扩展一个，都不需要修改原有系统。
				使用场景：当类存在两个独立变化的维度，当一个系统不希望使用继承或者因为多层次继承导致系统类的个数急剧增加时。
			5.外观模式  （外观角色，子系统角色） 是迪米特法则的典型应用。 降低客户端与子系统的复杂度。
			6.组合模式	用于把一组相似的对象当作一个单一的对象。创建的是一个树形结构。
				（抽象根节点-抽取数值节点与叶子节点的共同之处MenuComponent-为了一致的对象树枝对象和叶子对象 树枝节点Menu  叶子节点MenuItem）
					透明组合模式：抽象根节点角色声明了所有用于管理成员对象的方法。不够安全，因为叶子节点和数值节点的操作不一样。
					安全组合模式：抽象构建角色中没有声明任何用于管理成员对象的方法。所以叶子构建和容器构建有不同的方法，缺点是不够透明。客户端无法完全针对抽象编程。
			7.享元模式
				（抽象享元角色，具体享元角色，非享元，享元工厂）
					Integer i = 127, 自动装箱Interger i = Integer.valueOf(127); IntergerCache.cache()

三、行为型模式： 类和对象之间相互写作完成单个对象无法完成的任务  11种：访问者通过中介命令观察者使用模板策略提升责任，在备忘录里循环的解释自己的状态
			1. 命令模式  		Waiter    Command	  Receiver
			2. 责任链模式		抽象处理者（自己聚合自己）  具体处理者   客户类
			3. 观察者模式（发布订阅模式） 抽象主题/抽象被观察者（添加删除观察者，聚合观察者集合）  具体主题   抽象观察者  具体观察者
			4. 模板方法模式		父类定义流程方法   子类复写具体方法
			5. 策略模式		  （抽象策略，具体策略，环境）
			6. 访问者模式		Home.action Person.feed Owner Someone Animal.accept Cat Dog  将数据结构（Cat,Dog）与数据元素的操作(Feed)进行了分离
			7. 迭代器模式		
			8. 中介者模式		抽象中介者（定义交互方法）Mediator  具体中介者（聚合各方同事）MediatorStructure  抽象同事类Person(聚合抽象中介者类)   具体同事类HouseOwner,Tenant
			9. 备忘录模式		黑箱备忘录（将备忘录角色定义在发起人角色内部作为私有内部类）  白箱备忘录  （发起人角色，备忘录角色，管理者角色）
			10.解析器模式		
			11.状态模式			将状态提取到不同的状态对象中，通过面向对象的方式实现同样的逻辑。（抽象状态（定义公用方法  如电梯开关启停）聚合环境对象，具体状态，环境聚合抽象状态）
			
		